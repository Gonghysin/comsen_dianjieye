import torch
from main import smiles_to_graph, EnhancedMolecularGraph
from torch_geometric.data import Batch
import time

def predict_molecule(smiles, model_path="best_model.pt"):
    """预测单个分子的性质
    
    参数:
        smiles: 分子的SMILES表示
        model_path: 模型文件路径
        
    返回:
        预测值或None（如果预测失败）
    """
    print(f"\n{'='*50}")
    print(f"开始预测分子: {smiles}")
    print(f"{'='*50}")
    start_time = time.time()
    
    # 确定设备
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f"使用设备: {device}")
    
    # 加载模型和参数
    print(f"正在加载模型: {model_path}")
    try:
        checkpoint = torch.load(model_path, map_location=device)
        print(f"✓ 模型加载成功")
    except Exception as e:
        print(f"✗ 模型加载失败: {e}")
        return None
    
    # 获取归一化参数
    y_mean = checkpoint['y_mean']
    y_std = checkpoint['y_std']
    print(f"模型归一化参数 - 均值: {y_mean:.4f}, 标准差: {y_std:.4f}")
    
    # 将SMILES转换为图
    print(f"处理分子SMILES: {smiles}")
    graph = smiles_to_graph(smiles)
    if graph is None:
        print(f"✗ 错误: 无法将SMILES字符串转换为分子图")
        return None
    
    print(f"✓ 分子图生成成功 - 节点数: {graph.x.size(0)}, 边数: {graph.edge_index.size(1)//2}")
    
    # 初始化模型
    print("创建模型结构...")
    model = EnhancedMolecularGraph(
        num_node_features=graph.x.size(1),
        num_edge_features=graph.edge_attr.size(1)
    ).to(device)
    
    # 加载模型权重
    print("加载模型权重...")
    model.load_state_dict(checkpoint['model_state_dict'])
    model_params = sum(p.numel() for p in model.parameters())
    print(f"✓ 权重加载成功 - 模型参数总数: {model_params:,}")
    
    # 设置为评估模式
    model.eval()
    
    # 预测
    graph = graph.to(device)
    print("执行预测...")
    with torch.no_grad():
        out = model(Batch.from_data_list([graph]))
        prediction = out.item() * y_std + y_mean
    
    elapsed_time = time.time() - start_time
    print(f"预测完成! 耗时: {elapsed_time:.2f}秒")
    print(f"{'*'*20}")
    print(f"预测结果: {prediction:.4f}")
    print(f"{'*'*20}")
    
    return prediction

if __name__ == "__main__":
    print("分子性质预测工具")
    print("-" * 30)
    
    # 预定义一些常见分子示例
    examples = {
        "1": ("C1=CC=CC=C1", "苯"),
        "2": ("CCO", "乙醇"),
        "3": ("CC(=O)O", "乙酸"),
        "4": ("C1CCCCC1", "环己烷"),
        "5": ("CC(=O)OC1=CC=CC=C1C(=O)O", "阿司匹林")
    }
    
    print("预定义分子示例:")
    for key, (smiles, name) in examples.items():
        print(f"{key}. {name} ({smiles})")
    
    print("\n请选择预定义分子编号，或输入自定义SMILES字符串:")
    user_input = input("> ")
    
    # 检查是否选择了预定义分子
    if user_input in examples:
        smiles, name = examples[user_input]
        print(f"您选择了: {name}")
    else:
        smiles = user_input
    
    # 执行预测
    result = predict_molecule(smiles)
    
    # 交互式循环
    while True:
        print("\n输入新的SMILES进行预测，或输入数字选择预定义分子，或输入'exit'退出:")
        user_input = input("> ")
        
        if user_input.lower() == 'exit':
            print("谢谢使用，再见!")
            break
        
        if user_input in examples:
            smiles, name = examples[user_input]
            print(f"您选择了: {name}")
        else:
            smiles = user_input
        
        predict_molecule(smiles)
